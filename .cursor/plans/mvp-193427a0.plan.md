<!-- 193427a0-e73d-4be6-b416-ba0f09ae912b fa703401-296b-4ab6-b02a-1615cfb7d33d -->

# MVP - Multi-Agent Scheduling System (Next.js 16 + AI SDK v6)

## Overview

Build Phase 1 MVP leveraging Next.js 16's Server Components, Cache Components, PPR, AI SDK v6 for multi-agent orchestration, and Workflow for background job processing.

## Architecture Highlights

**Modern Stack:**

- Next.js 16 with full Server Components (React 19.2)
- AI SDK v6 for unified AI provider API
- Workflow for background jobs (email processing, meeting prep)
- Cache Components with "use cache" directive
- Partial Prerendering (PPR) for instant navigation
- Turbopack (stable) for fast builds

**Server-First Design:**

- All pages are Server Components by default
- Client Components only where interactivity needed
- Streaming UI with Suspense boundaries
- Edge-optimized with proxy.ts

## Project Setup & Foundation

### 1. Initialize Next.js 16 Project

```bash
npx create-next-app@latest casper --typescript --app --turbopack
```

Configure `next.config.ts`:

```typescript
import type { NextConfig } from "next";

const config: NextConfig = {
  // Enable Cache Components (opt-in caching)
  cacheComponents: true,

  // Turbopack is now default
  turbopack: {
    // Turbopack config if needed
  },

  experimental: {
    // Enable React Compiler for auto-memoization
    reactCompiler: true,
  },
};

export default config;
```

**Project Structure:**

```
/app
  /(marketing)
    /page.tsx - Landing page (Server Component)
  /(auth)
    /login/page.tsx
    /signup/page.tsx
  /(dashboard)
    /page.tsx - Main dashboard (Server Component with PPR)
    /threads/[id]/page.tsx - Thread details
    /@modal - Parallel route for modals
  /api
    /workflow - Workflow endpoints
/components
  /ui - shadcn components
  /server - Server Components
  /client - Client Components (marked with "use client")
/lib
  /agents - AI SDK v6 agents
  /workflow - Workflow job definitions
  /integrations - Gmail, Calendar APIs
  /supabase - Database client (Server Component compatible)
  /actions - Server Actions
/proxy.ts - Request interception (replaces middleware.ts)
```

### 2. Install Dependencies

```bash
# AI SDK v6
npm install ai @ai-sdk/openai @ai-sdk/anthropic

# Workflow (Vercel background jobs)
npm install @vercel/workflow

# Database & Auth
npm install @supabase/supabase-js @supabase/ssr

# Integrations
npm install googleapis zod date-fns

# UI
npx shadcn@latest init
npx shadcn@latest add button card input label select separator skeleton
```

**Key Packages:**

- `ai` v6 - Unified AI SDK with generateObject, streamText, experimental_generateText
- `@vercel/workflow` - Background job orchestration
- `@supabase/ssr` - Server Component compatible Supabase client
- `googleapis` - Gmail & Calendar APIs
- `zod` - Schema validation for AI outputs

### 3. Supabase Setup with Server Components

**Database Schema:**

```sql
-- User preferences
CREATE TABLE user_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users NOT NULL UNIQUE,
  gmail_access_token TEXT,
  gmail_refresh_token TEXT,
  calendar_id TEXT,
  timezone TEXT DEFAULT 'UTC',
  assistant_email TEXT, -- user's scheduling assistant email
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Email threads (for Gmail webhook processing)
CREATE TABLE email_threads (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users NOT NULL,
  thread_id TEXT NOT NULL UNIQUE,
  subject TEXT,
  participants TEXT[],
  status TEXT DEFAULT 'pending', -- pending, processing, scheduled, failed
  intent TEXT, -- schedule, reschedule, cancel
  workflow_run_id TEXT, -- link to Workflow job
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Meetings
CREATE TABLE meetings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users NOT NULL,
  email_thread_id UUID REFERENCES email_threads,
  title TEXT NOT NULL,
  participants TEXT[],
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,
  timezone TEXT NOT NULL,
  calendar_event_id TEXT,
  zoom_link TEXT,
  status TEXT DEFAULT 'proposed', -- proposed, confirmed, cancelled
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Workflow job tracking
CREATE TABLE workflow_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workflow_run_id TEXT NOT NULL UNIQUE,
  job_type TEXT NOT NULL, -- email_parse, schedule, prep, followup
  user_id UUID REFERENCES auth.users,
  status TEXT DEFAULT 'running',
  input JSONB,
  output JSONB,
  error TEXT,
  started_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

-- Agent logs (debugging)
CREATE TABLE agent_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID,
  agent_name TEXT NOT NULL,
  model TEXT,
  input JSONB,
  output JSONB,
  latency_ms INTEGER,
  tokens_used INTEGER,
  timestamp TIMESTAMPTZ DEFAULT NOW()
);
```

**RLS Policies:** Enable Row Level Security on all tables.

**Server Component Client (`/lib/supabase/server.ts`):**

```typescript
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            cookieStore.set(name, value, options)
          );
        },
      },
    }
  );
}
```

### 4. Landing Page with Server Components

**Landing Page (`/app/(marketing)/page.tsx`):**

```typescript
import { Button } from "@/components/ui/button";
import Link from "next/link";

export default async function HomePage() {
  return (
    <main className="min-h-screen">
      <section className="hero">
        <h1>Kaspr - AI that finds the moment</h1>
        <p>Your AI scheduling assistant that works via email</p>
        <Link href="/signup">
          <Button size="lg">Get Started</Button>
        </Link>
      </section>

      <section className="features">
        {/* Features showcase using Server Components */}
      </section>
    </main>
  );
}
```

**Use "use cache" for static sections:**

```typescript
"use cache";

export async function FeaturesSection() {
  // This component is cached automatically
  return <div>Features content...</div>;
}
```

### 5. Authentication with Supabase + Google OAuth

**Google OAuth Setup:**

1. Google Cloud Console: Enable Gmail + Calendar APIs
2. Create OAuth 2.0 credentials
3. Configure Supabase Auth with Google provider
4. Add Gmail and Calendar scopes

**Server Action for Login (`/lib/actions/auth.ts`):**

```typescript
"use server";

import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";

export async function signInWithGoogle() {
  const supabase = await createClient();

  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: "google",
    options: {
      redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/auth/callback`,
      scopes:
        "https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/calendar",
    },
  });

  if (error) throw error;
  redirect(data.url);
}
```

**Login Page (`/app/(auth)/login/page.tsx`):**

```typescript
import { signInWithGoogle } from "@/lib/actions/auth";
import { Button } from "@/components/ui/button";

export default function LoginPage() {
  return (
    <form action={signInWithGoogle}>
      <Button type="submit">Continue with Google</Button>
    </form>
  );
}
```

### 6. proxy.ts for Request Interception

**`/proxy.ts` (replaces middleware.ts):**

```typescript
import { type NextRequest, NextResponse } from "next/server";
import { createServerClient } from "@supabase/ssr";

export default async function proxy(request: NextRequest) {
  const response = NextResponse.next();

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            response.cookies.set(name, value, options)
          );
        },
      },
    }
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Protect dashboard routes
  if (request.nextUrl.pathname.startsWith("/dashboard") && !user) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  return response;
}

export const config = {
  matcher: ["/dashboard/:path*"],
};
```

## AI SDK v6 Multi-Agent System

### 7. AI SDK v6 Agent Implementation

Reference: [AI SDK v6 Documentation](https://v6.ai-sdk.dev/)

**Base Agent Setup (`/lib/agents/base.ts`):**

```typescript
import { generateObject, generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import { anthropic } from "@ai-sdk/anthropic";
import { z } from "zod";

export const DEFAULT_MODEL = openai("gpt-4o");

export async function runAgent<T extends z.ZodType>(
  agentName: string,
  prompt: string,
  schema: T,
  userId?: string
) {
  const startTime = Date.now();

  const result = await generateObject({
    model: DEFAULT_MODEL,
    schema,
    prompt,
  });

  // Log to database for debugging
  await logAgentRun(
    agentName,
    prompt,
    result.object,
    Date.now() - startTime,
    userId
  );

  return result.object;
}
```

**Email Parser Agent (`/lib/agents/email-parser.ts`):**

```typescript
import { z } from "zod";
import { runAgent } from "./base";

const emailIntentSchema = z.object({
  intent: z.enum(["schedule", "reschedule", "cancel", "info_request"]),
  participants: z.array(z.string().email()),
  proposedTimes: z.array(z.string()).optional(),
  duration: z.number().optional(),
  title: z.string(),
  context: z.string(),
  urgency: z.enum(["low", "medium", "high"]),
});

export async function parseEmail(
  emailBody: string,
  subject: string,
  userId: string
) {
  return await runAgent(
    "email-parser",
    `Parse this scheduling email and extract structured information:
    
    Subject: ${subject}
    Body: ${emailBody}
    
    Extract the scheduling intent, participants, proposed times, duration, and context.`,
    emailIntentSchema,
    userId
  );
}
```

**Calendar Agent (`/lib/agents/calendar.ts`):**

```typescript
import { z } from "zod";
import { runAgent } from "./base";
import { getCalendarEvents } from "@/lib/integrations/calendar";

const timeSlotSchema = z.object({
  slots: z.array(
    z.object({
      start: z.string(),
      end: z.string(),
      score: z.number(),
      reason: z.string(),
    })
  ),
});

export async function findOptimalSlots(
  participants: string[],
  duration: number,
  preferences: any,
  userId: string
) {
  // Get all participants' calendar events
  const calendars = await Promise.all(
    participants.map((email) => getCalendarEvents(email, userId))
  );

  const prompt = `Find 3 optimal meeting slots for ${duration} minutes.
  
  Calendars: ${JSON.stringify(calendars)}
  Preferences: ${JSON.stringify(preferences)}
  
  Consider: work hours, buffer time, conflict avoidance, timezone.`;

  return await runAgent("calendar", prompt, timeSlotSchema, userId);
}
```

**Response Generator Agent (`/lib/agents/response.ts`):**

```typescript
import { streamText } from "ai";
import { openai } from "@ai-sdk/openai";

export async function generateEmailResponse(context: any, timeSlots: any[]) {
  const result = streamText({
    model: openai("gpt-4o"),
    prompt: `Generate a friendly email response proposing these meeting times:
    
    Context: ${JSON.stringify(context)}
    Time Slots: ${JSON.stringify(timeSlots)}
    
    Keep it natural, professional, and concise.`,
  });

  return result.textStream;
}
```

## Workflow Integration for Background Jobs

Reference: [Workflow Documentation](https://useworkflow.dev/)

### 8. Workflow Setup for Email Processing

**Workflow Job (`/lib/workflow/email-processor.ts`):**

```typescript
import { workflow } from "@vercel/workflow";
import { parseEmail } from "@/lib/agents/email-parser";
import { findOptimalSlots } from "@/lib/agents/calendar";
import { sendEmail } from "@/lib/integrations/gmail";

export const processSchedulingEmail = workflow(
  "process-scheduling-email",
  async ({ threadId, userId }: { threadId: string; userId: string }) => {
    // Step 1: Fetch email from Gmail
    const email = await step.run("fetch-email", async () => {
      return await fetchEmailThread(threadId, userId);
    });

    // Step 2: Parse with AI
    const parsed = await step.run("parse-intent", async () => {
      return await parseEmail(email.body, email.subject, userId);
    });

    // Step 3: Find calendar slots
    const slots = await step.run("find-slots", async () => {
      return await findOptimalSlots(
        parsed.participants,
        parsed.duration || 30,
        {}, // user preferences
        userId
      );
    });

    // Step 4: Generate response
    const response = await step.run("generate-response", async () => {
      const stream = await generateEmailResponse(parsed, slots.slots);
      let fullText = "";
      for await (const chunk of stream) {
        fullText += chunk;
      }
      return fullText;
    });

    // Step 5: Send email
    await step.run("send-email", async () => {
      return await sendEmail(email.from, response, threadId, userId);
    });

    return { success: true, threadId };
  }
);
```

**Trigger Workflow from API (`/app/api/workflow/trigger/route.ts`):**

```typescript
import { NextResponse } from "next/server";
import { processSchedulingEmail } from "@/lib/workflow/email-processor";

export async function POST(request: Request) {
  const { threadId, userId } = await request.json();

  const run = await processSchedulingEmail.trigger({
    threadId,
    userId,
  });

  return NextResponse.json({ runId: run.id });
}
```

### 9. Gmail Webhook Handler

**Gmail Push Notification (`/app/api/emails/webhook/route.ts`):**

```typescript
import { NextResponse } from "next/server";
import { processSchedulingEmail } from "@/lib/workflow/email-processor";
import { createClient } from "@/lib/supabase/server";

export async function POST(request: Request) {
  const data = await request.json();

  // Decode Gmail push notification
  const message = JSON.parse(
    Buffer.from(data.message.data, "base64").toString()
  );

  const { emailAddress, historyId } = message;

  // Get user from email
  const supabase = await createClient();
  const { data: user } = await supabase
    .from("user_preferences")
    .select("user_id")
    .eq("assistant_email", emailAddress)
    .single();

  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  // Trigger Workflow job (runs in background)
  const run = await processSchedulingEmail.trigger({
    threadId: message.threadId,
    userId: user.user_id,
  });

  return NextResponse.json({ success: true, runId: run.id });
}
```

## Dashboard with Server Components & PPR

### 10. Dashboard with Server Components & PPR

**Dashboard Features Overview:**

**Phase 1 MVP Dashboard:**

1. **Main Dashboard Page** (`/app/(dashboard)/page.tsx`)
2. **Email Threads View**
3. **Calendar Overview**
4. **Settings Page**
5. **Onboarding Flow**

---

#### **1. Main Dashboard - Overview Page**

**Layout:**

- Sidebar navigation (left)
- Main content area (center)
- Quick actions panel (right, optional)

**Components:**

**A. Stats Cards (Top Row)** - Server Components with PPR

```typescript
// Stats that update in real-time
- Meetings This Week: 12
- Pending Scheduling Requests: 3
- Response Time: 4.2 min avg
- Success Rate: 95%
```

**B. Email Threads List (Primary Section)**

```typescript
interface ThreadItem {
  id: string;
  subject: string;
  participants: string[];
  status: "pending" | "processing" | "scheduled" | "failed";
  intent: "schedule" | "reschedule" | "cancel";
  lastMessage: string;
  timestamp: Date;
  workflowRunId?: string;
}
```

**Features:**

- Real-time status updates (using Supabase Realtime)
- Filter by status (pending/processing/scheduled/failed)
- Search threads by participant or subject
- Click to view full conversation
- Manual override buttons ("Approve", "Edit", "Cancel")
- Agent processing indicator (shows which agent is working)

**C. Upcoming Meetings Widget**

```typescript
// Calendar view of next 7 days
- Meeting cards with:
  - Title, time, duration
  - Participants (with avatars)
  - Location/Zoom link
  - Status (confirmed/proposed)
  - Quick actions (reschedule, cancel, join)
```

---

#### **2. Thread Detail Page** (`/app/(dashboard)/threads/[id]/page.tsx`)

**Full conversation view:**

**A. Email Thread Timeline**

- Chronological display of all emails in thread
- Shows AI agent analysis for each message
- Displays intent classification, extracted data
- Syntax-highlighted JSON output (for debugging)

**B. Agent Processing Status**

```typescript
// Visual workflow of agent execution
Coordinator → Intent → Preference → Calendar → Timezone → Conflict → Response

// Show current step with:
- ✅ Completed steps (green)
- ⏳ Current step (yellow, animated)
- ⏸️ Pending steps (gray)
- ❌ Failed steps (red, with error message)
```

**C. Proposed Time Slots**

```typescript
// Card-based layout showing AI-suggested times
Each slot card shows:
- Date & Time (in user's timezone)
- Score (0-100)
- Reasoning ("Good slot: no conflicts, preferred time window")
- Participant availability (visual indicator per person)
- Actions: "Approve", "Edit", "Suggest Alternative"
```

**D. Calendar Conflict View**

- Visual timeline showing conflicts
- Overlapping meetings highlighted
- Buffer time violations marked
- Alternative suggestions

**E. Manual Override Section**

- Edit proposed times
- Add/remove participants
- Change meeting duration
- Override AI suggestions
- Force send response

---

#### **3. Calendar View** (`/app/(dashboard)/calendar/page.tsx`)

**Features:**

**A. Monthly/Weekly/Daily Views**

- Full calendar component (use shadcn calendar or a library)
- Color-coded meetings: - Blue: Confirmed meetings - Yellow: Proposed meetings (pending approval) - Red: Conflicts detected - Green: Available slots

**B. Meeting Details Panel**

- Click any meeting to see details
- Quick actions (reschedule, cancel, join Zoom)
- Show all participants' timezones
- Display preparation status (if Prep Agent ran)

**C. Availability Heatmap**

- Visual representation of busy/free times
- Show patterns ("You're busiest on Mondays 2-4pm")
- Suggest focus time blocks

---

#### **4. Settings Page** (`/app/(dashboard)/settings/page.tsx`)

**Sections:**

**A. Profile Settings**

- Name, email, timezone
- Working hours (start/end time)
- Preferred meeting duration
- Buffer time between meetings (15/30/60 min)

**B. Connected Integrations**

```typescript
// Show status of each integration
- [✅] Google Calendar (connected)
- [✅] Gmail (connected)
- [⚠️] Zoom (reconnect needed)
- [➕] Slack (connect)
- [➕] Outlook (connect)
```

**C. Preferences**

```typescript
// User can set explicit preferences
- Preferred meeting times: [9am-11am, 2pm-4pm]
- Avoid times: [12pm-1pm lunch, after 5pm]
- Meeting type preferences:
  - Client calls: 60 min, need 30 min prep
  - Internal syncs: 30 min, back-to-back OK
  - 1-on-1s: 30 min, prefer mornings
```

**D. AI Agent Settings**

- Enable/disable specific agents
- Adjust agent behavior (conservative vs aggressive scheduling)
- Auto-approve vs manual approval mode
- Email response tone (formal/casual/friendly)

**E. Assistant Email**

```typescript
// Show user's dedicated scheduling assistant email
your-assistant@casper.ai

Instructions:
"CC this email in your scheduling requests.
Example: 'Schedule coffee with Sarah next week' → CC: your-assistant@casper.ai"
```

**F. Notification Preferences**

- Email notifications (on/off)
- Browser notifications (on/off)
- Slack notifications (on/off)
- Notification events: - New scheduling request received - Meeting scheduled successfully - Conflict detected - Requires manual approval

---

#### **5. Onboarding Flow** (`/app/(dashboard)/onboarding/page.tsx`)

**First-time user experience:**

**Step 1: Connect Google Account**

- OAuth flow for Gmail + Calendar
- Explain permissions needed
- Show security features

**Step 2: Set Working Hours**

- Select timezone
- Set work hours (9am-5pm default)
- Set buffer preferences

**Step 3: Get Your Assistant Email**

- Display unique assistant email
- Show example usage
- Test email send

**Step 4: First Scheduling Request**

- Interactive tutorial
- "Try scheduling a meeting with yourself"
- Watch agents work in real-time

---

#### **6. Additional Dashboard Features**

**A. Search & Filters** (Top Bar)

```typescript
// Global search across:
- Email threads
- Meetings
- Participants
- Date ranges

// Filters:
- Status: pending/scheduled/failed
- Date range: last 7 days/30 days/all time
- Meeting type: client/internal/interview
```

**B. Quick Actions Menu** (Floating Action Button)

```typescript
// Accessible from anywhere in dashboard
- Schedule meeting manually
- View today's agenda
- Check availability
- Contact support
```

**C. Agent Activity Log** (`/app/(dashboard)/logs/page.tsx`)

```typescript
// For debugging and transparency
Show recent agent executions:
- Agent name
- Input/Output
- Execution time
- Success/failure
- Error messages (if any)
- Token usage
```

**D. User Profile Menu** (Top Right)

```typescript
- Settings
- Billing (future)
- Help & Documentation
- Sign out
```

---

#### **Implementation with Server Components**

**Main Dashboard (`/app/(dashboard)/page.tsx`):**

```typescript
import { Suspense } from "react";
import { createClient } from "@/lib/supabase/server";
import { StatsCards } from "@/components/server/stats-cards";
import { ThreadList } from "@/components/server/thread-list";
import { UpcomingMeetings } from "@/components/server/upcoming-meetings";
import { Skeleton } from "@/components/ui/skeleton";

export default async function DashboardPage() {
  return (
    <div className="flex h-screen">
      {/* Sidebar */}
      <aside className="w-64 border-r">
        <DashboardNav />
      </aside>

      {/* Main Content */}
      <main className="flex-1 overflow-y-auto p-6">
        <h1 className="text-3xl font-bold mb-6">Dashboard</h1>

        {/* Stats Cards - PPR: Static shell, dynamic data streams */}
        <Suspense fallback={<StatsCardsSkeleton />}>
          <StatsCards />
        </Suspense>

        {/* Thread List */}
        <div className="mt-8">
          <h2 className="text-2xl font-semibold mb-4">Recent Requests</h2>
          <Suspense fallback={<Skeleton className="h-96" />}>
            <ThreadList />
          </Suspense>
        </div>

        {/* Upcoming Meetings */}
        <div className="mt-8">
          <h2 className="text-2xl font-semibold mb-4">Upcoming Meetings</h2>
          <Suspense fallback={<Skeleton className="h-64" />}>
            <UpcomingMeetings />
          </Suspense>
        </div>
      </main>
    </div>
  );
}

// Server Component for stats
async function StatsCards() {
  const supabase = await createClient();
  const { data: user } = await supabase.auth.getUser();

  // Fetch stats
  const [meetingsCount, pendingCount, avgResponse] = await Promise.all([
    supabase.from("meetings").select("count").eq("user_id", user.id),
    supabase.from("email_threads").select("count").eq("status", "pending"),
    supabase.from("agent_logs").select("latency_ms").limit(100),
  ]);

  return (
    <StatsCardsClient data={{ meetingsCount, pendingCount, avgResponse }} />
  );
}

// Server Component for thread list
async function ThreadList() {
  const supabase = await createClient();
  const { data: threads } = await supabase
    .from("email_threads")
    .select("*, meetings(*)")
    .order("created_at", { ascending: false })
    .limit(20);

  return <ThreadListClient threads={threads || []} />;
}
```

**Use "use cache" for frequently accessed data:**

```typescript
"use cache";

export async function getCachedUserPreferences(userId: string) {
  const supabase = await createClient();
  const { data } = await supabase
    .from("user_preferences")
    .select("*")
    .eq("user_id", userId)
    .single();

  return data;
}
```

**Real-time Updates with Supabase:**

```typescript
"use client";

import { createClient } from "@/lib/supabase/client";
import { useEffect, useState } from "react";

export function ThreadListClient({ threads: initialThreads }) {
  const [threads, setThreads] = useState(initialThreads);
  const supabase = createClient();

  useEffect(() => {
    // Subscribe to real-time changes
    const channel = supabase
      .channel("email_threads")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "email_threads" },
        (payload) => {
          // Update threads in real-time
          setThreads((current) => updateThreads(current, payload));
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, []);

  return <ThreadListUI threads={threads} />;
}
```

---

#### **Design System with shadcn/ui**

**Components to install:**

```bash
npx shadcn@latest add button card badge avatar separator skeleton tabs
npx shadcn@latest add dialog dropdown-menu select input label
npx shadcn@latest add table calendar tooltip popover
```

**Color Scheme:**

- Primary: Blue (scheduling actions)
- Success: Green (confirmed meetings)
- Warning: Yellow (pending approval)
- Danger: Red (conflicts, errors)
- Muted: Gray (past meetings)

---

This gives you a **complete, production-ready dashboard** that shows off the multi-agent system and provides all the features users need!

### 11. Integrations

**Gmail Integration (`/lib/integrations/gmail.ts`):**

- OAuth token management
- Fetch email threads
- Send emails via Gmail API
- Set up push notifications

**Google Calendar Integration (`/lib/integrations/calendar.ts`):**

- Fetch events in date range
- Create/update/delete events
- Check availability for multiple participants
- Handle timezones

**Zoom Integration (`/lib/integrations/zoom.ts`):**

- Generate Zoom meeting links
- Auto-add to calendar events

## Environment Variables

```bash
# App
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Supabase
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=

# AI SDK v6
OPENAI_API_KEY=
ANTHROPIC_API_KEY= # optional

# Google APIs
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
GOOGLE_REDIRECT_URI=

# Workflow (Vercel)
WORKFLOW_API_KEY=

# Zoom (optional)
ZOOM_CLIENT_ID=
ZOOM_CLIENT_SECRET=
```

## Testing & Deployment

**Local Testing:**

```bash
npm run dev # Uses Turbopack by default
```

**Build & Deploy:**

```bash
npm run build
vercel --prod
```

**Vercel Configuration:**

- Enable Workflow in project settings
- Set environment variables
- Configure domains for Gmail webhooks

---

## Future Features (Phase 2-5)

### Phase 2: Intelligence Layer - Multi-Agent Enhancements (Weeks 5-7)

**New Agents:**

**1. Preference Learning Agent**

- Analyzes past scheduling patterns from database
- Learns individual preferences: "prefers 9-11am slots", "needs 15-min buffer", "hates early mornings"
- Stores learned patterns in user_preferences table
- Auto-applies preferences to future scheduling
- Tracks meeting type preferences (client calls vs internal syncs)

**2. Timezone Agent**

- Handles global team scheduling across timezones
- Converts meeting times correctly for all participants
- Finds fair meeting times (rotate who has early/late slots)
- Displays times in each participant's local timezone
- Prevents timezone confusion errors

**3. Conflict Resolution Agent**

- Proactively detects scheduling conflicts BEFORE booking
- Identifies hard conflicts (overlapping meetings) and soft conflicts (back-to-back with no buffer)
- Suggests alternative time slots automatically
- Smart rescheduling: "Your flight lands at 2pm, should I move the 3pm call?"
- Prevents double-booking embarrassments

**4. Enhanced Coordinator Agent**

- Multi-turn conversation state management
- Context carrying across email exchanges
- Remembers previous conversation in thread
- Intelligent routing between specialized agents
- Handles complex scheduling flows (reschedule → check conflicts → suggest alternatives)

**Enhanced Features:**

- Context-aware scheduling (understands meeting purpose: client vs internal)
- Team pattern learning (entire team preferences)
- Meeting type detection and optimization
- Energy level consideration (avoid meetings during low-productivity hours)
- Travel time buffer (adds buffer if previous meeting is at different location)

**Database Updates:**

- Add preferences JSONB column to user_preferences table
- Add conversation_state table for multi-turn tracking
- Add team_preferences table for organization-wide patterns

### Phase 3: Prep Agent (Weeks 8-10)

- Workflow job: 24h before meeting
- Research attendees (LinkedIn, email history)
- Generate agenda using AI SDK v6
- Send prep email

### Phase 4: Follow-up Agent (Weeks 11-13)

- Post-meeting workflow
- Transcription integration (Deepgram)
- Action item extraction with AI
- Auto-schedule follow-ups
- CRM integration

### Phase 5: Analytics & Polish (Weeks 14-15)

- Analytics dashboard with PPR
- Meeting pattern visualization
- Productivity insights
- Additional integrations (Slack, Outlook, Linear)
- Mobile optimization
